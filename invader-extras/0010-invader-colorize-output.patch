From 060b8514227fddbaf101a9f8cc943476dd8cf081 Mon Sep 17 00:00:00 2001
From: Kamil Dudka <kdudka@redhat.com>
Date: Sun, 1 Nov 2009 13:49:12 +0100
Subject: [PATCH 2/2] invader: colorize output

---
 sources/abs.ml       |    2 +-
 sources/dom.ml       |   10 +++++-----
 sources/footprint.ml |   20 ++++++++++----------
 sources/ident.ml     |    2 +-
 sources/interproc.ml |   20 ++++++++++----------
 sources/locality.ml  |    2 +-
 sources/prop.ml      |    2 +-
 sources/propset.ml   |    4 ++--
 sources/sil.ml       |   29 ++++++++++++++++-------------
 sources/symExec.ml   |   26 +++++++++++++-------------
 10 files changed, 60 insertions(+), 57 deletions(-)

diff --git a/sources/abs.ml b/sources/abs.ml
index 6b6144d..fcb9af1 100644
--- a/sources/abs.ml
+++ b/sources/abs.ml
@@ -1489,7 +1489,7 @@ let abstract_junk prop =
     in 
     if should_remove_hpred && not (!Config.allowleak)
     then begin 
-      E.err "@[\n.... Prop with garbage ....@.";
+      E.err "@[\n.... \x1B[1;31mProp with garbage\x1B[0m ....@.";
       E.err "@[<4>  PROP: %a@\n@." pp_prop prop;
       E.err "@[<4>  PREDICATE: %a@\n@." pp_hpred_full hpred;
       assert false
diff --git a/sources/dom.ml b/sources/dom.ml
index 9c0ab17..04135b5 100644
--- a/sources/dom.ml
+++ b/sources/dom.ml
@@ -647,10 +647,10 @@ let rec sigma_partial_join' (sigma_acc:sigma)
   try
     let todo_curr = Todo.pop () in
     let e1, e2, e = todo_curr in
-    E.log "@[<2>.... sigma_partial_join' ....@\n";
-    E.log "@\nTODO: %a,%a,%a@\n" Sil.pp_exp e1 Sil.pp_exp e2 Sil.pp_exp e;
-    E.log "@\nPROP1=%a@\n" pp_sigma sigma1_in;
-    E.log "@\nPROP2=%a@\n@." pp_sigma sigma2_in; 
+    E.log "@[<2>.... \x1B[1;33msigma_partial_join'\x1B[0m ....@\n";
+    E.log "@\n\x1B[1;35mTODO\x1B[0m: %a,%a,%a@\n" Sil.pp_exp e1 Sil.pp_exp e2 Sil.pp_exp e;
+    E.log "@\n\x1B[1;35mPROP1\x1B[0m=%a@\n" pp_sigma sigma1_in;
+    E.log "@\n\x1B[1;35mPROP2\x1B[0m=%a@\n@." pp_sigma sigma2_in; 
     let hpred_opt1, sigma1 = find_hpred_by_address e1 sigma1_in in
     let hpred_opt2, sigma2 = find_hpred_by_address e2 sigma2_in in
     match hpred_opt1, hpred_opt2 with
@@ -972,7 +972,7 @@ let propset_join pset1 pset2 =
   let rec join_prop_plist plist2_acc p2 = function 
     | [] -> (p2, List.rev plist2_acc)
     | p2'::plist2_rest -> begin
-	E.log "@[<2>.... JOIN ....@\n";
+    E.log "@[<2>.... \x1B[1;32mJOIN\x1B[0m ....@\n";
 	E.log "@\nJOIN SYM HEAP1: %a@\n" pp_prop p2;
 	E.log "@\nJOIN SYM HEAP2: %a@\n@." pp_prop p2';
 	match prop_partial_join p2 p2' with
diff --git a/sources/footprint.ml b/sources/footprint.ml
index fd8d6ca..0ca123b 100644
--- a/sources/footprint.ml
+++ b/sources/footprint.ml
@@ -235,9 +235,9 @@ let converging_node node =
   | _ -> false
 
 let exe_instrs dset instrl = 
-  E.log "@[.... Translated Instrs ....@]\n%a@." pp_instr_list instrl;
+  E.log "@[.... \x1B[1;32mTranslated Instrs\x1B[0m ....@]\n%a@." pp_instr_list instrl;
   let dset' = List.fold_left SymExec.lifted_sym_exec dset instrl in
-  E.log "@[<2>.... After Symbolic Execution ....@]\n%a\n@." Propset.pp_propset dset'; 
+  E.log "@[<2>.... \x1B[1;32mAfter Symbolic Execution\x1B[0m ....@]\n%a\n@." Propset.pp_propset dset'; 
   dset'
 
 let remove_temp_pvars dset node =
@@ -256,9 +256,9 @@ let do_symbolic_execution (node : node) (d:prop) =
 	| Prune_node (sil, e) -> 
             let dset' = exe_instrs dset sil in
 	    let dset'' = SymExec.prune e dset' in
-              E.log "@[<2>.... Prune ....@]\n";
-              E.log "EXP: %a\n" pp_exp e;
-              E.log "PROPSET:\n";
+              E.log "@[<2>.... \x1B[1;33mPrune\x1B[0m ....@]\n";
+              E.log "\x1B[1;35mEXP:\x1B[0m %a\n" pp_exp e;
+              E.log "\x1B[1;35mPROPSET:\x1B[0m\n";
               E.log "%a\n@." Propset.pp_propset dset'';
               dset''          
 	| Stmt_node sil | Return_Site_node sil -> 
@@ -330,12 +330,12 @@ let do_join curr_node edgeset_todo =
  * applies the abstraction. *)
 let doInstr2 (dset: Propset.propset) (ids, instrs): Propset.propset = 
   let _ = 
-    E.log "@[.... Translated Instrs ....\n%a@." pp_instr_list instrs in
+    E.log "@[.... \x1B[1;32mTranslated Instrs\x1B[0m ....\n%a@." pp_instr_list instrs in
   let post_dset = List.fold_left SymExec.lifted_sym_exec dset instrs in
   let quantified_dset = SymExec.lifted_exist_quantify (fav_from_list ids) post_dset in    
   let new_dset = Abs.lifted_abstract quantified_dset 
   in 
-    E.log "@[<2>.... After Symbolic Execution ....\n%a@]\n@." Propset.pp_propset new_dset; 
+    E.log "@[<2>.... \x1B[1;32mAfter Symbolic Execution\x1B[0m ....\n%a@]\n@." Propset.pp_propset new_dset; 
     new_dset
 
 let prop_max_size = ref (0,prop_emp)
@@ -415,7 +415,7 @@ let forward_tabulate () =
 	    List.iter (propagate dset') succ_nodes)
 	  edgeset_todo
   done;
-  E.log "@[.... Work list empty. Stop ....@]\n@."
+  E.log "@[.... \x1B[1;33mWork list empty. Stop\x1B[0m ....@]\n@."
 
 let get_initial_node f =
   let proc_name = f.svar.vname in
@@ -507,7 +507,7 @@ let collect_postconditions pdesc : Propset.propset =
   let proc_name = proc_desc_to_proc_name pdesc in
   let pset = Propset.propset_map (deallocate_locals_formals pdesc) (collect_analysis_result pdesc) in
   let jplist = collect_do_join (collect_do_abstract pset) in
-  let () = E.log "@....[FUNCTION %s] Analysis result...@." proc_name in
+  let () = E.log "@....[FUNCTION \x1B[1;32m%s\x1B[0m] Analysis result...@." proc_name in
   let () = E.log "@.%a@." Propset.pp_propset pset
   in Propset.proplist2propset (List.map Dom.jprop_to_prop jplist)
 
@@ -563,7 +563,7 @@ let process_fun (f : Cil.fundec) : unit =
 	let results = collect_do_abstract (Propset.propset_map (deallocate_locals_formals pdesc) (collect_analysis_result pdesc)) in
 	  E.err "@.#### [FUNCTION %s] ...OK #####@." curr_f_name;
 	  E.err "@.@.#### Finished: Footprint Computation for %s ####@.@." curr_f_name;
-	  E.log "@....[FUNCTION %s] Footprint Analysis result...@." curr_f_name;
+	  E.log "@....[FUNCTION \x1B[1;32m%s\x1B[0m] Footprint Analysis result...@." curr_f_name;
 	  E.log "@.%a@." Propset.pp_propset results;
 	  results
 
diff --git a/sources/ident.ml b/sources/ident.ml
index f9243a8..751effa 100644
--- a/sources/ident.ml
+++ b/sources/ident.ml
@@ -235,7 +235,7 @@ let ident_to_string id =
     if id.kind==kfootprint then "@"
     else if id.kind==knormal then ""
     else "_" in
-  let suffix = "$" ^ (string_of_int id.stamp)
+  let suffix = "\x1B[1;36m$" ^ (string_of_int id.stamp) ^ "\x1B[0m"
   in prefix ^ base_name ^ suffix
 
 (** Print a sequence. *)
diff --git a/sources/interproc.ml b/sources/interproc.ml
index 3355fae..5e437fd 100644
--- a/sources/interproc.ml
+++ b/sources/interproc.ml
@@ -523,12 +523,12 @@ let deallocate_locals_formals_ret (pdesc : proc_desc) (d : Prop.prop) =
  * applies the abstraction. *)
 let doInstr2 (dset: Propset.propset) (ids, instrs): Propset.propset = 
   let _ = 
-    E.log "@[.... Translated Instrs ....@\n%a@." Sil.pp_instr_list instrs in
+    E.log "@[.... \x1B[1;32mTranslated Instrs\x1B[0m ....@\n%a@." Sil.pp_instr_list instrs in
   let post_dset = List.fold_left SymExec.lifted_sym_exec dset instrs in
   let quantified_dset = SymExec.lifted_exist_quantify (Sil.fav_from_list ids) post_dset in    
   let new_dset = Abs.lifted_abstract quantified_dset 
   in 
-    E.log "@[<2>.... After Symbolic Execution ....@\n%a@\n@." Propset.pp_propset new_dset; 
+    E.log "@[<2>.... \x1B[1;32mAfter Symbolic Execution\x1B[0m ....@\n%a@\n@." Propset.pp_propset new_dset; 
     new_dset 
 
 let converging_node node =
@@ -538,9 +538,9 @@ let converging_node node =
   | _ -> false
 
 let exe_instrs dset instrl = 
-  E.log "@[.... Translated Instrs ....@\n%a@." Sil.pp_instr_list instrl;
+  E.log "@[.... \x1B[1;32mTranslated Instrs\x1B[0m ....@\n%a@." Sil.pp_instr_list instrl;
   let dset' = List.fold_left SymExec.lifted_sym_exec dset instrl in
-  E.log "@[<2>.... After Symbolic Execution ....@\n%a@\n@." Propset.pp_propset dset'; 
+  E.log "@[<2>.... \x1B[1;32mAfter Symbolic Execution\x1B[0m ....@\n%a@\n@." Propset.pp_propset dset'; 
   dset'
 
 let remove_temp_pvars dset node =
@@ -559,9 +559,9 @@ let do_symbolic_execution (node : node) (d:Prop.prop) =
       | Prune_node (sil, e) -> 
           let dset' = exe_instrs dset sil in
 	  let dset'' = SymExec.prune e dset' in
-          E.log "@[<2>.... Prune ....@\n";
-          E.log "EXP: %a@\n" Sil.pp_exp e;
-          E.log "PROPSET:@\n";
+          E.log "@[<2>.... \x1B[1;33mPrune\x1B[0m ....@\n";
+          E.log "\x1B[1;35mEXP:\x1B[0m %a@\n" Sil.pp_exp e;
+          E.log "\x1B[1;35mPROPSET:\x1B[0m @\n";
           E.log "%a@\n@." Propset.pp_propset dset'';
           dset''          
       | Stmt_node sil | Return_Site_node sil -> 
@@ -590,7 +590,7 @@ let do_symbolic_execution_target_call
     : ((Ident.ident * Ident.ident) list * Prop.prop * Prop.prop) list =
   let initial_time = Stats.get_current_time () in
   let _ =
-    E.log "@[.... Prelude for Procedure %s ....@\n@." (proc_desc_to_proc_name callee_pdesc) 
+    E.log "@[.... Prelude for Procedure \x1B[1;32m%s\x1B[0m ....@\n@." (proc_desc_to_proc_name callee_pdesc) 
   in
   let caller_fundec = proc_desc_get_fundec caller_pdesc in
   let callee_fundec = proc_desc_get_fundec callee_pdesc in
@@ -706,7 +706,7 @@ let do_symbolic_execution_target_call
       in (cuts, do_frame d_split, do_nonframe d_split) 
     in List.map f ds_split
   in 
-    E.log "@[.... Finished Initialization and Splitting for Call to %s ....@\n@." 
+    E.log "@[.... Finished Initialization and Splitting for Call to \x1B[1;32m%s\x1B[0m ....@\n@." 
       (proc_desc_to_proc_name callee_pdesc);
     target_call_time := !target_call_time +. (Stats.get_current_time () -. initial_time);
     ds_split_res
@@ -1112,7 +1112,7 @@ let feature : featureDescr =
     Global.doit ();
     let results = rhs_tabulate f 
     in begin
-      E.err "@[.... Successfully Analyzed ....@\n@.";
+      E.err "@[.... \x1B[1;32mSuccessfully Analyzed\x1B[0m ....@\n@.";
       E.err "@[#### Final Results ####@\n@.";
       print_results results;
       Proc.display_stats();
diff --git a/sources/locality.ml b/sources/locality.ml
index c573e98..7c72a74 100644
--- a/sources/locality.ml
+++ b/sources/locality.ml
@@ -304,7 +304,7 @@ let split (callee:Cil.fundec) (globals: S.pvar list) (params:S.exp list)
     else if !Config.locality_level = 1 then
       let (cutpoints_info, p_unreach,p_reach) = compute_reachable callee globals nparams p 
       in 
-	E.log "@[<2>.... Split a Prop for Call to %s....@\n" (callee.svar.vname);
+	E.log "@[<2>.... Split a Prop for Call to \x1B[1;32m%s\x1B[0m....@\n" (callee.svar.vname);
 	E.log "In: %a@\n@\n" P.pp_prop p;
 	E.log "Unreach: %a@\n@\n" P.pp_prop p_unreach;
 	E.log "Reach: %a@\n@." P.pp_prop p_reach;
diff --git a/sources/prop.ml b/sources/prop.ml
index 76bd8b4..0d753fe 100644
--- a/sources/prop.ml
+++ b/sources/prop.ml
@@ -146,7 +146,7 @@ let rec pp_seq pp f = function
 let rec pp_star_seq pp f = function
   | [] -> ()
   | [x] -> fprintf f "%a" pp x
-  | x::l -> fprintf f "%a@ * %a" pp x (pp_star_seq pp) l
+  | x::l -> fprintf f "%a@ \x1B[1;31m*\x1B[0m %a" pp x (pp_star_seq pp) l
 
 
 (** Pretty print a footprint. *)
diff --git a/sources/propset.ml b/sources/propset.ml
index f50d845..0d04eb2 100644
--- a/sources/propset.ml
+++ b/sources/propset.ml
@@ -125,8 +125,8 @@ open Format
 let pp_proplist f plist =
   let rec pp_seq_newline n f = function
     | [] -> ()
-    | [x] -> fprintf f "PROP %d: %a" n pp_prop x
-    | x::l -> fprintf f "PROP %d: %a\n\n%a" n pp_prop x (pp_seq_newline (n+1)) l 
+    | [x] -> fprintf f "\x1B[1;35mPROP %d:\x1B[0m %a" n pp_prop x
+    | x::l -> fprintf f "\x1B[1;35mPROP %d:\x1B[0m %a\n\n%a" n pp_prop x (pp_seq_newline (n+1)) l 
   in pp_seq_newline 1 f plist
 
 
diff --git a/sources/sil.ml b/sources/sil.ml
index 80988d8..b49afd0 100644
--- a/sources/sil.ml
+++ b/sources/sil.ml
@@ -591,7 +591,7 @@ let pp_pair f ((fld:fieldname),(t:typ)) =
 
 (** Pretty print a program variable. *)
 let pp_pvar f pv =
-  fprintf f "%s$%a" pv.pv_funname pp_name pv.pv_name
+  fprintf f "%s$\x1B[1;34m%a\x1B[0m" pv.pv_funname pp_name pv.pv_name
 
 (** Pretty print a list of program variables. *)
 let pp_pvar_list f pvl =
@@ -600,12 +600,14 @@ let pp_pvar_list f pvl =
 (** Pretty print an expression. *)
 let rec pp_exp f = function
   | Var id -> pp_ident f id
-  | Const_int n -> fprintf f "%d" n
+  | Const_int n -> (match n with
+        | 0 -> fprintf f "\x1B[1;37mNULL\x1B[0m"
+        | _ -> fprintf f "\x1B[1;37m%d\x1B[0m" n)
   | Cast (typ,e) -> fprintf f "(%a)%a" pp_typ typ pp_exp e
   | UnOp (op,e) -> fprintf f "%s%a" (str_unop op) pp_exp e
   | BinOp (op,e1,e2) -> fprintf f "(%a%s%a)" pp_exp e1 (str_binop op) pp_exp e2
-  | Lvar pv -> fprintf f "&%a" pp_pvar pv
-  | Lfield (e,fld) -> fprintf f "%a.%a" pp_exp e pp_name fld
+  | Lvar pv -> fprintf f "&\x1B[1;32m%a\x1B[0m" pp_pvar pv
+  | Lfield (e,fld) -> fprintf f "%a.\x1B[1;33m%a\x1B[0m" pp_exp e pp_name fld
   | Lindex (e1,e2) -> fprintf f "%a[%a]" pp_exp e1 pp_exp e2
 
 let pp_exp_list f expl = 
@@ -644,14 +646,15 @@ let rec pp_instr_list f = function
   | i::is -> fprintf f "  %a;\n%a" pp_instr i pp_instr_list is
 
 let pp_atom f = function
-  | Aeq (e1,e2) -> fprintf f "%a=%a" pp_exp e1 pp_exp e2
-  | Aneq (e1,e2) -> fprintf f "%a!=%a" pp_exp e1 pp_exp e2
+  | Aeq (e1,e2) -> fprintf f "%a \x1B[1;33m=\x1B[0m %a" pp_exp e1 pp_exp e2
+  | Aneq (e1,e2) -> fprintf f "%a \x1B[1;33m!=\x1B[0m %a" pp_exp e1 pp_exp e2
 
 
 let rec pp_sexp f = function
   | Eexp e -> pp_exp f e
   | Estruct fel ->
-      fprintf f "{%a}" (pp_seq (fun f (n,se) -> fprintf f "%a:%a" pp_name n pp_sexp se)) fel
+      fprintf f "\x1B[1;32m{\x1B[0m%a\x1B[1;32m}\x1B[0m" (pp_seq (fun f (n,se) ->
+      fprintf f "\x1B[1;33m%a\x1B[0m:%a" pp_name n pp_sexp se)) fel
   | Earray (size,nel) ->
       fprintf f "[%d|%a]" size (pp_seq (fun f (i,se) -> fprintf f "%a:%a" pp_exp i pp_sexp se)) nel
 
@@ -662,15 +665,15 @@ let rec pp_star_seq pp f = function
   | x::l -> fprintf f "%a * %a" pp x (pp_star_seq pp) l
 
 let pp_lseg_kind f = function
-  | Lseg_NE -> fprintf f "ne"
-  | Lseg_PE -> fprintf f "pe"
+  | Lseg_NE -> fprintf f "\x1B[1;33mne\x1B[0m"
+  | Lseg_PE -> fprintf f "\x1B[1;33mpe\x1B[0m"
 
 let rec _pp_hpred f pp_t = function
-  | Hpointsto (e,se,t) -> fprintf f "%a|->%a:%a" pp_exp e pp_sexp se pp_t t
+  | Hpointsto (e,se,t) -> fprintf f "%a \x1B[1;31m|->\x1B[0m %a:%a" pp_exp e pp_sexp se pp_t t
   | Hlseg (k,pred,e1,e2,elist) -> 
-      fprintf f "lseg%a@ (%a)@ (%a,%a,%a)" pp_lseg_kind k pp_hpara pred pp_exp e1 pp_exp e2 (pp_seq pp_exp) elist
+      fprintf f "\x1B[1;31mlseg\x1B[0m%a@ (%a)@ (%a,%a,%a)" pp_lseg_kind k pp_hpara pred pp_exp e1 pp_exp e2 (pp_seq pp_exp) elist
   | Hdllseg (k,pred,iF,oB,oF,iB,elist) ->
-      fprintf f "dllseg%a@ (%a)@ (%a,%a,%a,%a,%a)" pp_lseg_kind k pp_dll_hpara pred pp_exp iF pp_exp oB  pp_exp oF pp_exp iB (pp_seq pp_exp) elist
+      fprintf f "\x1B[1;32mdl\x1B[0m\x1B[1;31mlseg%a\x1B[0m@ (%a)@ (%a,%a,%a,%a,%a)" pp_lseg_kind k pp_dll_hpara pred pp_exp iF pp_exp oB  pp_exp oF pp_exp iB (pp_seq pp_exp) elist
 
 and pp_hpred f = 
   _pp_hpred f pp_typ
@@ -680,7 +683,7 @@ and pp_hpred_full f =
 
 and pp_hpara f pred =
   let (r,n,svars, evars,b) = (pred.root, pred.next, pred.svars, pred.evars, pred.body) 
-  in fprintf f "lam [%a,%a,%a]. exists [%a]. %a" 
+  in fprintf f "\x1B[1;31mlam [\x1B[0m%a\x1B[1;31m,\x1B[0m%a\x1B[1;31m,\x1B[0m%a\x1B[1;31m]\x1B[0m. \x1B[1;31mex\x1B[0mists \x1B[1;31m[\x1B[0m%a\x1B[1;31m]\x1B[0m. %a" 
        pp_ident r 
        pp_ident n 
        (pp_seq pp_ident) svars
diff --git a/sources/symExec.ml b/sources/symExec.ml
index 8eaeff3..7610bd7 100644
--- a/sources/symExec.ml
+++ b/sources/symExec.ml
@@ -76,7 +76,7 @@ let rec unroll_type typ off = match (typ,off) with
       (try fldlist_assoc fld ftl 
 	with Not_found -> 
 	  begin
-            E.err "@[\n.... Invalid Field Access ....@]@.";
+            E.err "@[\n.... \x1B[1;31mInvalid Field Access\x1B[0m ....@]@.";
             E.err "@[<2>  Fld : %a@]\n" pp_name fld; 
             E.err "Type : %a\n@." pp_typ_full typ; 
             assert false
@@ -86,7 +86,7 @@ let rec unroll_type typ off = match (typ,off) with
   | (_, Off_index (Const_int 0)) ->
       typ
   | _ -> 
-      E.err "@[\n.... Invalid Field Access ....@]@.";
+      E.err "@[\n.... \x1B[1;31mInvalid Field Access\x1B[0m ....@]@.";
       E.err "@[<2>  Fld : %a@]\n" pp_offset off; 
       E.err "Type : %a\n@." pp_typ_full typ; 
       assert false
@@ -134,7 +134,7 @@ let rec construct_strexp exp offlist typ =
     if not found, expand [strexp] and apply [f] to [None] *)
 let rec apply_offlist strexp typ offlist (f: exp option -> exp) =
   let error () =
-    E.err "@[\n.... Invalid Field ....@]@.";
+    E.err "@[\n.... \x1B[1;31mInvalid Field\x1B[0m ....@]@.";
     E.err "@[<2>  strexp : %a@]\n" pp_sexp strexp; 
     E.err "offlist : %a\n" pp_offset_list offlist; 
     E.err "type : %a\n@." pp_typ_full typ;
@@ -212,9 +212,9 @@ let ptsto_update (lexp,strexp,typ) offlist exp =
 let name_n = string_to_name "n"
 
 let pp_rearrangement_error prop lexp =
-  E.err "@[\n.... Rearrangement Error ....@]@.";
-  E.err "@[<2>  Exp:%a@]\n" pp_exp lexp; 
-  E.err "Prop:%a\n@." pp_prop prop
+  E.err "@[\n.... \x1B[1;31mRearrangement Error\x1B[0m ....@]@.";
+  E.err "@[<2>  \x1B[1;35mExp: \x1B[0m%a@]\n" pp_exp lexp; 
+  E.err "\x1B[1;35mExpProp: \x1B[0m%a\n@." pp_prop prop
 
 (* Exposes lexp|->- from iter. In case that it is not possible to
  * expose lexp|->-, this function prints an error message and
@@ -396,9 +396,9 @@ let rearrange_arith lexp prop =
     inside [strexp]. *)
 let rearrange lexp typ prop =
   let lexp = exp_normalize_prop prop lexp in 
-  E.log "@[<2>.... Rearrangement Start ....@]\n";
-  E.log "Exp: %a\n" pp_exp lexp;
-  E.log "Prop: %a\n@." pp_prop prop;
+  E.log "@[<2>.... \x1B[1;33mRearrangement Start\x1B[0m ....@]\n";
+  E.log "\x1B[1;35mExp:\x1B[0m %a\n" pp_exp lexp;
+  E.log "\x1B[1;35mProp:\x1B[0m %a\n@." pp_prop prop;
   if (!Config.array_level >= 1 && Sil.exp_pointer_arith lexp) 
   then rearrange_arith lexp prop;
   match prop_iter_create prop with
@@ -524,7 +524,7 @@ let _sym_exec instr (prop:prop) =
          with ARRAY_ACCESS ->
            if (!Config.array_level = 0) then assert false 
            else 
-             E.err "@[.... Array containing allocated heap cells ...@.";
+             E.err "@[.... \x1B[1;31mArray containing allocated heap cells\x1B[0m ...@.";
              E.err "@[<4>  Instr: %a@]@." pp_instr instr;
              E.err "@[<4>  PROP: %a@." pp_prop prop;
              assert false)
@@ -536,7 +536,7 @@ let _sym_exec instr (prop:prop) =
          with ARRAY_ACCESS ->
            if (!Config.array_level = 0) then assert false 
            else 
-             E.err "@[.... Array containing allocated heap cells ...@.";
+             E.err "@[.... \x1B[1;31mArray containing allocated heap cells\x1B[0m ...@.";
              E.err "@[<4>  Instr: %a@]@." pp_instr instr;
              E.err "@[<4>  PROP: %a@." pp_prop prop;
              assert false)
@@ -565,7 +565,7 @@ let _sym_exec instr (prop:prop) =
            begin 
              match is_root prop lexp lexp with
 	     | None -> 
-                 E.err "@[\n.... Alignment Error: Freed a non root ....@]@."; 
+                 E.err "@[\n.... \x1B[1;31mAlignment Error: Freed a non root\x1B[0m ....@]@."; 
                  assert false 
              | Some _ ->
       	         List.map execute_free (rearrange lexp typ prop)
@@ -573,7 +573,7 @@ let _sym_exec instr (prop:prop) =
          with ARRAY_ACCESS ->
            if (!Config.array_level = 0) then assert false 
            else 
-             E.err "@[.... Array containing allocated heap cells ...@.";
+             E.err "@[.... \x1B[1;31mArray containing allocated heap cells\x1B[0m ...@.";
              E.err "@[<4>  Instr: %a@]@." pp_instr instr;
              E.err "@[<4>  PROP: %a@." pp_prop prop;
              assert false)
-- 
1.6.5.rc1

